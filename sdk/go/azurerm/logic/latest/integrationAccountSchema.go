// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package latest

import (
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v2/go/pulumi"
)

// The integration account schema.
//
// ## Example Usage
// ### Create or update schema
//
// ```go
// package main
//
// import (
// 	logic "github.com/pulumi/pulumi-azurerm/sdk/go/azurerm/logic/latest"
// 	"github.com/pulumi/pulumi/sdk/v2/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		_, err := logic.NewIntegrationAccountSchema(ctx, "integrationAccountSchema", &logic.IntegrationAccountSchemaArgs{
// 			Content: pulumi.String("<?xml version=\"1.0\" encoding=\"utf-16\"?>\n<xs:schema xmlns:b=\"http://schemas.microsoft.com/BizTalk/2003\" xmlns=\"http://Inbound_EDI.OrderFile\" targetNamespace=\"http://Inbound_EDI.OrderFile\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">\n  <xs:annotation>\n    <xs:appinfo>\n      <b:schemaInfo default_pad_char=\" \" count_positions_by_byte=\"false\" parser_optimization=\"speed\" lookahead_depth=\"3\" suppress_empty_nodes=\"false\" generate_empty_nodes=\"true\" allow_early_termination=\"false\" early_terminate_optional_fields=\"false\" allow_message_breakup_of_infix_root=\"false\" compile_parse_tables=\"false\" standard=\"Flat File\" root_reference=\"OrderFile\" />\n      <schemaEditorExtension:schemaInfo namespaceAlias=\"b\" extensionClass=\"Microsoft.BizTalk.FlatFileExtension.FlatFileExtension\" standardName=\"Flat File\" xmlns:schemaEditorExtension=\"http://schemas.microsoft.com/BizTalk/2003/SchemaEditorExtensions\" />\n    </xs:appinfo>\n  </xs:annotation>\n  <xs:element name=\"OrderFile\">\n    <xs:annotation>\n      <xs:appinfo>\n        <b:recordInfo structure=\"delimited\" preserve_delimiter_for_empty_data=\"true\" suppress_trailing_delimiters=\"false\" sequence_number=\"1\" />\n      </xs:appinfo>\n    </xs:annotation>\n    <xs:complexType>\n      <xs:sequence>\n        <xs:annotation>\n          <xs:appinfo>\n            <b:groupInfo sequence_number=\"0\" />\n          </xs:appinfo>\n        </xs:annotation>\n        <xs:element name=\"Order\">\n          <xs:annotation>\n            <xs:appinfo>\n              <b:recordInfo sequence_number=\"1\" structure=\"delimited\" preserve_delimiter_for_empty_data=\"true\" suppress_trailing_delimiters=\"false\" child_delimiter_type=\"hex\" child_delimiter=\"0x0D 0x0A\" child_order=\"infix\" />\n            </xs:appinfo>\n          </xs:annotation>\n          <xs:complexType>\n            <xs:sequence>\n              <xs:annotation>\n                <xs:appinfo>\n                  <b:groupInfo sequence_number=\"0\" />\n                </xs:appinfo>\n              </xs:annotation>\n              <xs:element name=\"Header\">\n                <xs:annotation>\n                  <xs:appinfo>\n                    <b:recordInfo sequence_number=\"1\" structure=\"delimited\" preserve_delimiter_for_empty_data=\"true\" suppress_trailing_delimiters=\"false\" child_delimiter_type=\"char\" child_delimiter=\"|\" child_order=\"infix\" tag_name=\"HDR|\" />\n                  </xs:appinfo>\n                </xs:annotation>\n                <xs:complexType>\n                  <xs:sequence>\n                    <xs:annotation>\n                      <xs:appinfo>\n                        <b:groupInfo sequence_number=\"0\" />\n                      </xs:appinfo>\n                    </xs:annotation>\n                    <xs:element name=\"PODate\" type=\"xs:string\">\n                      <xs:annotation>\n                        <xs:appinfo>\n                          <b:fieldInfo sequence_number=\"1\" justification=\"left\" />\n                        </xs:appinfo>\n                      </xs:annotation>\n                    </xs:element>\n                    <xs:element name=\"PONumber\" type=\"xs:string\">\n                      <xs:annotation>\n                        <xs:appinfo>\n                          <b:fieldInfo justification=\"left\" sequence_number=\"2\" />\n                        </xs:appinfo>\n                      </xs:annotation>\n                    </xs:element>\n                    <xs:element name=\"CustomerID\" type=\"xs:string\">\n                      <xs:annotation>\n                        <xs:appinfo>\n                          <b:fieldInfo sequence_number=\"3\" justification=\"left\" />\n                        </xs:appinfo>\n                      </xs:annotation>\n                    </xs:element>\n                    <xs:element name=\"CustomerContactName\" type=\"xs:string\">\n                      <xs:annotation>\n                        <xs:appinfo>\n                          <b:fieldInfo sequence_number=\"4\" justification=\"left\" />\n                        </xs:appinfo>\n                      </xs:annotation>\n                    </xs:element>\n                    <xs:element name=\"CustomerContactPhone\" type=\"xs:string\">\n                      <xs:annotation>\n                        <xs:appinfo>\n                          <b:fieldInfo sequence_number=\"5\" justification=\"left\" />\n                        </xs:appinfo>\n                      </xs:annotation>\n                    </xs:element>\n                  </xs:sequence>\n                </xs:complexType>\n              </xs:element>\n              <xs:element minOccurs=\"1\" maxOccurs=\"unbounded\" name=\"LineItems\">\n                <xs:annotation>\n                  <xs:appinfo>\n                    <b:recordInfo sequence_number=\"2\" structure=\"delimited\" preserve_delimiter_for_empty_data=\"true\" suppress_trailing_delimiters=\"false\" child_delimiter_type=\"char\" child_delimiter=\"|\" child_order=\"infix\" tag_name=\"DTL|\" />\n                  </xs:appinfo>\n                </xs:annotation>\n                <xs:complexType>\n                  <xs:sequence>\n                    <xs:annotation>\n                      <xs:appinfo>\n                        <b:groupInfo sequence_number=\"0\" />\n                      </xs:appinfo>\n                    </xs:annotation>\n                    <xs:element name=\"PONumber\" type=\"xs:string\">\n                      <xs:annotation>\n                        <xs:appinfo>\n                          <b:fieldInfo sequence_number=\"1\" justification=\"left\" />\n                        </xs:appinfo>\n                      </xs:annotation>\n                    </xs:element>\n                    <xs:element name=\"ItemOrdered\" type=\"xs:string\">\n                      <xs:annotation>\n                        <xs:appinfo>\n                          <b:fieldInfo sequence_number=\"2\" justification=\"left\" />\n                        </xs:appinfo>\n                      </xs:annotation>\n                    </xs:element>\n                    <xs:element name=\"Quantity\" type=\"xs:string\">\n                      <xs:annotation>\n                        <xs:appinfo>\n                          <b:fieldInfo sequence_number=\"3\" justification=\"left\" />\n                        </xs:appinfo>\n                      </xs:annotation>\n                    </xs:element>\n                    <xs:element name=\"UOM\" type=\"xs:string\">\n                      <xs:annotation>\n                        <xs:appinfo>\n                          <b:fieldInfo sequence_number=\"4\" justification=\"left\" />\n                        </xs:appinfo>\n                      </xs:annotation>\n                    </xs:element>\n                    <xs:element name=\"Price\" type=\"xs:string\">\n                      <xs:annotation>\n                        <xs:appinfo>\n                          <b:fieldInfo sequence_number=\"5\" justification=\"left\" />\n                        </xs:appinfo>\n                      </xs:annotation>\n                    </xs:element>\n                    <xs:element name=\"ExtendedPrice\" type=\"xs:string\">\n                      <xs:annotation>\n                        <xs:appinfo>\n                          <b:fieldInfo sequence_number=\"6\" justification=\"left\" />\n                        </xs:appinfo>\n                      </xs:annotation>\n                    </xs:element>\n                    <xs:element name=\"Description\" type=\"xs:string\">\n                      <xs:annotation>\n                        <xs:appinfo>\n                          <b:fieldInfo sequence_number=\"7\" justification=\"left\" />\n                        </xs:appinfo>\n                      </xs:annotation>\n                    </xs:element>\n                  </xs:sequence>\n                </xs:complexType>\n              </xs:element>\n            </xs:sequence>\n          </xs:complexType>\n        </xs:element>\n      </xs:sequence>\n    </xs:complexType>\n  </xs:element>\n</xs:schema>"),
// 			ContentType:            pulumi.String("application/xml"),
// 			IntegrationAccountName: pulumi.String("testIntegrationAccount"),
// 			Location:               pulumi.String("westus"),
// 			Metadata:               nil,
// 			ResourceGroupName:      pulumi.String("testResourceGroup"),
// 			SchemaName:             pulumi.String("testSchema"),
// 			SchemaType:             pulumi.String("Xml"),
// 			Tags: pulumi.StringMap{
// 				"integrationAccountSchemaName": pulumi.String("IntegrationAccountSchema8120"),
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
//
// ```
type IntegrationAccountSchema struct {
	pulumi.CustomResourceState

	// The changed time.
	ChangedTime pulumi.StringOutput `pulumi:"changedTime"`
	// The content.
	Content pulumi.StringPtrOutput `pulumi:"content"`
	// The content link.
	ContentLink ContentLinkResponseOutput `pulumi:"contentLink"`
	// The content type.
	ContentType pulumi.StringPtrOutput `pulumi:"contentType"`
	// The created time.
	CreatedTime pulumi.StringOutput `pulumi:"createdTime"`
	// The document name.
	DocumentName pulumi.StringPtrOutput `pulumi:"documentName"`
	// The file name.
	FileName pulumi.StringPtrOutput `pulumi:"fileName"`
	// The resource location.
	Location pulumi.StringPtrOutput `pulumi:"location"`
	// The metadata.
	Metadata pulumi.MapOutput `pulumi:"metadata"`
	// Gets the resource name.
	Name pulumi.StringOutput `pulumi:"name"`
	// The schema type.
	SchemaType pulumi.StringOutput `pulumi:"schemaType"`
	// The resource tags.
	Tags pulumi.StringMapOutput `pulumi:"tags"`
	// The target namespace of the schema.
	TargetNamespace pulumi.StringPtrOutput `pulumi:"targetNamespace"`
	// Gets the resource type.
	Type pulumi.StringOutput `pulumi:"type"`
}

// NewIntegrationAccountSchema registers a new resource with the given unique name, arguments, and options.
func NewIntegrationAccountSchema(ctx *pulumi.Context,
	name string, args *IntegrationAccountSchemaArgs, opts ...pulumi.ResourceOption) (*IntegrationAccountSchema, error) {
	if args == nil || args.IntegrationAccountName == nil {
		return nil, errors.New("missing required argument 'IntegrationAccountName'")
	}
	if args == nil || args.ResourceGroupName == nil {
		return nil, errors.New("missing required argument 'ResourceGroupName'")
	}
	if args == nil || args.SchemaName == nil {
		return nil, errors.New("missing required argument 'SchemaName'")
	}
	if args == nil || args.SchemaType == nil {
		return nil, errors.New("missing required argument 'SchemaType'")
	}
	if args == nil {
		args = &IntegrationAccountSchemaArgs{}
	}
	aliases := pulumi.Aliases([]pulumi.Alias{
		{
			Type: pulumi.String("azurerm:logic/v20150801preview:IntegrationAccountSchema"),
		},
		{
			Type: pulumi.String("azurerm:logic/v20160601:IntegrationAccountSchema"),
		},
		{
			Type: pulumi.String("azurerm:logic/v20180701preview:IntegrationAccountSchema"),
		},
		{
			Type: pulumi.String("azurerm:logic/v20190501:IntegrationAccountSchema"),
		},
	})
	opts = append(opts, aliases)
	var resource IntegrationAccountSchema
	err := ctx.RegisterResource("azurerm:logic/latest:IntegrationAccountSchema", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetIntegrationAccountSchema gets an existing IntegrationAccountSchema resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetIntegrationAccountSchema(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *IntegrationAccountSchemaState, opts ...pulumi.ResourceOption) (*IntegrationAccountSchema, error) {
	var resource IntegrationAccountSchema
	err := ctx.ReadResource("azurerm:logic/latest:IntegrationAccountSchema", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering IntegrationAccountSchema resources.
type integrationAccountSchemaState struct {
	// The changed time.
	ChangedTime *string `pulumi:"changedTime"`
	// The content.
	Content *string `pulumi:"content"`
	// The content link.
	ContentLink *ContentLinkResponse `pulumi:"contentLink"`
	// The content type.
	ContentType *string `pulumi:"contentType"`
	// The created time.
	CreatedTime *string `pulumi:"createdTime"`
	// The document name.
	DocumentName *string `pulumi:"documentName"`
	// The file name.
	FileName *string `pulumi:"fileName"`
	// The resource location.
	Location *string `pulumi:"location"`
	// The metadata.
	Metadata map[string]interface{} `pulumi:"metadata"`
	// Gets the resource name.
	Name *string `pulumi:"name"`
	// The schema type.
	SchemaType *string `pulumi:"schemaType"`
	// The resource tags.
	Tags map[string]string `pulumi:"tags"`
	// The target namespace of the schema.
	TargetNamespace *string `pulumi:"targetNamespace"`
	// Gets the resource type.
	Type *string `pulumi:"type"`
}

type IntegrationAccountSchemaState struct {
	// The changed time.
	ChangedTime pulumi.StringPtrInput
	// The content.
	Content pulumi.StringPtrInput
	// The content link.
	ContentLink ContentLinkResponsePtrInput
	// The content type.
	ContentType pulumi.StringPtrInput
	// The created time.
	CreatedTime pulumi.StringPtrInput
	// The document name.
	DocumentName pulumi.StringPtrInput
	// The file name.
	FileName pulumi.StringPtrInput
	// The resource location.
	Location pulumi.StringPtrInput
	// The metadata.
	Metadata pulumi.MapInput
	// Gets the resource name.
	Name pulumi.StringPtrInput
	// The schema type.
	SchemaType pulumi.StringPtrInput
	// The resource tags.
	Tags pulumi.StringMapInput
	// The target namespace of the schema.
	TargetNamespace pulumi.StringPtrInput
	// Gets the resource type.
	Type pulumi.StringPtrInput
}

func (IntegrationAccountSchemaState) ElementType() reflect.Type {
	return reflect.TypeOf((*integrationAccountSchemaState)(nil)).Elem()
}

type integrationAccountSchemaArgs struct {
	// The content.
	Content *string `pulumi:"content"`
	// The content type.
	ContentType *string `pulumi:"contentType"`
	// The document name.
	DocumentName *string `pulumi:"documentName"`
	// The file name.
	FileName *string `pulumi:"fileName"`
	// The integration account name.
	IntegrationAccountName string `pulumi:"integrationAccountName"`
	// The resource location.
	Location *string `pulumi:"location"`
	// The metadata.
	Metadata map[string]interface{} `pulumi:"metadata"`
	// The resource group name.
	ResourceGroupName string `pulumi:"resourceGroupName"`
	// The integration account schema name.
	SchemaName string `pulumi:"schemaName"`
	// The schema type.
	SchemaType string `pulumi:"schemaType"`
	// The resource tags.
	Tags map[string]string `pulumi:"tags"`
	// The target namespace of the schema.
	TargetNamespace *string `pulumi:"targetNamespace"`
}

// The set of arguments for constructing a IntegrationAccountSchema resource.
type IntegrationAccountSchemaArgs struct {
	// The content.
	Content pulumi.StringPtrInput
	// The content type.
	ContentType pulumi.StringPtrInput
	// The document name.
	DocumentName pulumi.StringPtrInput
	// The file name.
	FileName pulumi.StringPtrInput
	// The integration account name.
	IntegrationAccountName pulumi.StringInput
	// The resource location.
	Location pulumi.StringPtrInput
	// The metadata.
	Metadata pulumi.MapInput
	// The resource group name.
	ResourceGroupName pulumi.StringInput
	// The integration account schema name.
	SchemaName pulumi.StringInput
	// The schema type.
	SchemaType pulumi.StringInput
	// The resource tags.
	Tags pulumi.StringMapInput
	// The target namespace of the schema.
	TargetNamespace pulumi.StringPtrInput
}

func (IntegrationAccountSchemaArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*integrationAccountSchemaArgs)(nil)).Elem()
}
